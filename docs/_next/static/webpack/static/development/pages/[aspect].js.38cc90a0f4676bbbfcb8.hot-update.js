webpackHotUpdate("static/development/pages/[aspect].js",{

/***/ "./src/features/dependency/resolveDependency.ts":
/*!******************************************************!*\
  !*** ./src/features/dependency/resolveDependency.ts ***!
  \******************************************************/
/*! exports provided: resolveAllDependency, resolveDependency */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolveAllDependency\", function() { return resolveAllDependency; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolveDependency\", function() { return resolveDependency; });\n/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @reduxjs/toolkit */ \"./node_modules/@reduxjs/toolkit/dist/redux-toolkit.esm.js\");\n/* harmony import */ var _StepNodeRecord__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StepNodeRecord */ \"./src/features/dependency/StepNodeRecord.ts\");\n/* harmony import */ var _DependencyQueue__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DependencyQueue */ \"./src/features/dependency/DependencyQueue.ts\");\n/* harmony import */ var _isIncludedInDependencyArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isIncludedInDependencyArray */ \"./src/features/dependency/isIncludedInDependencyArray.ts\");\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* eslint-disable no-param-reassign */\n\n\n\n\n\nvar initiateInvertDependency = function initiateInvertDependency(_ref) {\n  var invertDependencyChecks = _ref.invertDependencyChecks,\n      stepId = _ref.stepId,\n      type = _ref.type;\n\n  if (!invertDependencyChecks[type]) {\n    invertDependencyChecks[type] = {};\n  }\n\n  if (!invertDependencyChecks[type][stepId]) {\n    invertDependencyChecks[type][stepId] = {\n      dependencyCheckList: []\n    };\n  }\n};\n\nvar addNodeToQueueFactory = function addNodeToQueueFactory(queue) {\n  return function (node) {\n    // construct nextNode\n    var nextNode = {\n      scriptType: node.type,\n      stepId: node.stepId\n    };\n\n    if (queue.includes(nextNode)) {\n      // if nextNode is met in the queue before,\n      // it means there's circular dependency\n      throw new Error('circular dependency detected');\n    } else {\n      // nextNode is safe to add to queue\n      queue.push(nextNode);\n    }\n  };\n};\n\nvar insertNodeIntoInvertDependencyChecks = function insertNodeIntoInvertDependencyChecks(_ref2) {\n  var node = _ref2.node,\n      currentNode = _ref2.currentNode,\n      invertDependencyChecks = _ref2.invertDependencyChecks;\n  // construct invert dependency node\n  var invertDependency = {\n    stepId: currentNode.stepId,\n    type: currentNode.scriptType,\n    choice: node.choice\n  }; // initiate state for the node if not initiated\n\n  initiateInvertDependency(_objectSpread({\n    invertDependencyChecks: invertDependencyChecks\n  }, node));\n\n  if (currentNode.scriptType === 'delete' && currentNode.stepId === 'B') {\n    console.log('hello');\n  } // insert the invert dependency node only if not existed\n  // in the node's invert dependency check list\n\n\n  var invertDependencyCheckList = invertDependencyChecks[node.type][node.stepId].dependencyCheckList;\n\n  if (!Object(_isIncludedInDependencyArray__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n    dependency: invertDependency,\n    array: invertDependencyCheckList\n  })) {\n    invertDependencyCheckList.push(invertDependency);\n  }\n};\n\nvar insertNodeIntoDependencyCheckListFactory = function insertNodeIntoDependencyCheckListFactory(_ref3) {\n  var index = _ref3.index,\n      dependencyCheckList = _ref3.dependencyCheckList,\n      currentNode = _ref3.currentNode,\n      invertDependencyChecks = _ref3.invertDependencyChecks;\n  return function (node) {\n    // insert dependency node only if not existed\n    if (!Object(_isIncludedInDependencyArray__WEBPACK_IMPORTED_MODULE_5__[\"default\"])({\n      dependency: node,\n      array: dependencyCheckList\n    })) {\n      dependencyCheckList.splice(index, 0, node);\n    }\n\n    insertNodeIntoInvertDependencyChecks({\n      node: node,\n      currentNode: currentNode,\n      invertDependencyChecks: invertDependencyChecks\n    });\n  };\n};\n\nvar resolveAllDependency = function resolveAllDependency(_ref4) {\n  var dependencyChecks = _ref4.dependencyChecks,\n      _ref4$invertDependenc = _ref4.invertDependencyChecks,\n      invertDependencyChecks = _ref4$invertDependenc === void 0 ? {} : _ref4$invertDependenc;\n  return Object(_reduxjs_toolkit__WEBPACK_IMPORTED_MODULE_2__[\"createNextState\"])({\n    dependencyChecks: dependencyChecks,\n    invertDependencyChecks: invertDependencyChecks\n  }, function (draft) {\n    var draftDependencyChecks = draft.dependencyChecks,\n        draftInvertDependencyChecks = draft.invertDependencyChecks;\n    var resolved = new _StepNodeRecord__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n    var seen = new _StepNodeRecord__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n    Object.keys(draftDependencyChecks).forEach(function (scriptType) {\n      // loop through each scriptType\n      draftDependencyChecks[scriptType].ids.forEach(function (id) {\n        // loop through each dependency element in each scriptType\n        var stepId = id.toString(); // initiate queue\n\n        var queue = new _DependencyQueue__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n          scriptType: scriptType,\n          stepId: stepId\n        }); // declare function to add a node to queue\n        // use first scriptType as default type\n\n        var addNodeToQueue = addNodeToQueueFactory(queue);\n\n        while (queue.length) {\n          // make sure processing every node in queue\n          // current pointer node\n          var nodeToCheck = queue[queue.length - 1]; // find the current node in the state\n\n          var stepToUpdate = draftDependencyChecks[nodeToCheck.scriptType].entities[nodeToCheck.stepId];\n\n          if (resolved.includes(nodeToCheck)) {\n            // if current node is resolved\n            queue.pop();\n          } else if (stepToUpdate) {\n            // current node still have dependency to resolve\n            if (!seen.includes(nodeToCheck)) {\n              // if current node not seen before\n              // initiate current node's dependency array\n              stepToUpdate.dependencyCheckList = Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(stepToUpdate.dependency); // add current node to seen\n\n              seen.add(nodeToCheck); // add all dependent node to queue\n\n              stepToUpdate.dependency.forEach(addNodeToQueue);\n            } else {\n              // current node has been seen before\n              // it implies that current node have all nodes in dependency resolved\n              var _stepToUpdate$depende = stepToUpdate.dependencyCheckList,\n                  dependencyCheckList = _stepToUpdate$depende === void 0 ? [] : _stepToUpdate$depende;\n\n              for (var i = dependencyCheckList.length - 1; i >= 0; i -= 1) {\n                var _draftDependencyCheck;\n\n                // loop through every node in current dependency check list from the end\n                // step that corresponds to current node to replace\n                var stepToReplace = (_draftDependencyCheck = draftDependencyChecks[dependencyCheckList[i].type || '']) === null || _draftDependencyCheck === void 0 ? void 0 : _draftDependencyCheck.entities[dependencyCheckList[i].stepId];\n\n                if (stepToReplace) {\n                  var _stepToReplace$depend;\n\n                  // if stepToReplace exists\n                  // it means the stepToReplace has dependencyCheckList to replace\n                  // remove the current nodeToReplace first\n                  var nodeToReplace = dependencyCheckList.splice(i, 1)[0]; // copy stepToReplace's dependencyCheckList to stepToUpdate's dependencyCheckList\n                  // without duplicated nodes\n                  // eslint-disable-next-line no-unused-expressions\n\n                  (_stepToReplace$depend = stepToReplace.dependencyCheckList) === null || _stepToReplace$depend === void 0 ? void 0 : _stepToReplace$depend.forEach(insertNodeIntoDependencyCheckListFactory({\n                    index: i,\n                    dependencyCheckList: dependencyCheckList,\n                    currentNode: nodeToCheck,\n                    invertDependencyChecks: draftInvertDependencyChecks\n                  })); // insert the current nodeToReplace again if not exists\n\n                  insertNodeIntoDependencyCheckListFactory({\n                    index: i,\n                    dependencyCheckList: dependencyCheckList,\n                    currentNode: nodeToCheck,\n                    invertDependencyChecks: draftInvertDependencyChecks\n                  })(nodeToReplace);\n                } else {\n                  insertNodeIntoInvertDependencyChecks({\n                    node: dependencyCheckList[i],\n                    currentNode: nodeToCheck,\n                    invertDependencyChecks: invertDependencyChecks\n                  });\n                }\n              }\n\n              resolved.add(nodeToCheck);\n              queue.pop();\n            }\n          } else {\n            // current node does not have any dependency\n            resolved.add(nodeToCheck);\n            queue.pop();\n          }\n        }\n      });\n    });\n    return draft;\n  });\n};\nvar resolveDependency = function resolveDependency() {};\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports_1 = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports_1;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZmVhdHVyZXMvZGVwZW5kZW5jeS9yZXNvbHZlRGVwZW5kZW5jeS50cz8xMjAzIl0sIm5hbWVzIjpbImluaXRpYXRlSW52ZXJ0RGVwZW5kZW5jeSIsImludmVydERlcGVuZGVuY3lDaGVja3MiLCJzdGVwSWQiLCJ0eXBlIiwiZGVwZW5kZW5jeUNoZWNrTGlzdCIsImFkZE5vZGVUb1F1ZXVlRmFjdG9yeSIsInF1ZXVlIiwibm9kZSIsIm5leHROb2RlIiwic2NyaXB0VHlwZSIsImluY2x1ZGVzIiwiRXJyb3IiLCJwdXNoIiwiaW5zZXJ0Tm9kZUludG9JbnZlcnREZXBlbmRlbmN5Q2hlY2tzIiwiY3VycmVudE5vZGUiLCJpbnZlcnREZXBlbmRlbmN5IiwiY2hvaWNlIiwiY29uc29sZSIsImxvZyIsImludmVydERlcGVuZGVuY3lDaGVja0xpc3QiLCJpc0luY2x1ZGVkSW5EZXBlbmRlbmN5QXJyYXkiLCJkZXBlbmRlbmN5IiwiYXJyYXkiLCJpbnNlcnROb2RlSW50b0RlcGVuZGVuY3lDaGVja0xpc3RGYWN0b3J5IiwiaW5kZXgiLCJzcGxpY2UiLCJyZXNvbHZlQWxsRGVwZW5kZW5jeSIsImRlcGVuZGVuY3lDaGVja3MiLCJwcm9kdWNlIiwiZHJhZnQiLCJkcmFmdERlcGVuZGVuY3lDaGVja3MiLCJkcmFmdEludmVydERlcGVuZGVuY3lDaGVja3MiLCJyZXNvbHZlZCIsIlN0ZXBOb2RlUmVjb3JkIiwic2VlbiIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiaWRzIiwiaWQiLCJ0b1N0cmluZyIsIkRlcGVuZGVuY3lRdWV1ZSIsImFkZE5vZGVUb1F1ZXVlIiwibGVuZ3RoIiwibm9kZVRvQ2hlY2siLCJzdGVwVG9VcGRhdGUiLCJlbnRpdGllcyIsInBvcCIsImFkZCIsImkiLCJzdGVwVG9SZXBsYWNlIiwibm9kZVRvUmVwbGFjZSIsInJlc29sdmVEZXBlbmRlbmN5Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFD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QUFULENBQWFKLFdBQWI7QUFDQXRDLGlCQUFLLENBQUN5QyxHQUFOO0FBQ0Q7QUFDRjtBQUNGLE9BMUZEO0FBMkZELEtBN0ZEO0FBK0ZBLFdBQU9sQixLQUFQO0FBQ0QsR0F6R00sQ0FKMkI7QUFBQSxDQUE3QjtBQStHQSxJQUFNdUIsaUJBQWlCLEdBQUcsU0FBcEJBLGlCQUFvQixHQUFNLENBQUUsQ0FBbEMiLCJmaWxlIjoiLi9zcmMvZmVhdHVyZXMvZGVwZW5kZW5jeS9yZXNvbHZlRGVwZW5kZW5jeS50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG5pbXBvcnQgeyBjcmVhdGVOZXh0U3RhdGUgYXMgcHJvZHVjZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IHtcbiAgRGVwZW5kZW5jeUNoZWNrc1N0YXRlLFxuICBJbnZlcnREZXBlbmRlbmN5Q2hlY2tzU3RhdGUsXG59IGZyb20gJy4vZGVwZW5kZW5jeUNoZWNrU2xpY2UnO1xuaW1wb3J0IFN0ZXBOb2RlUmVjb3JkIGZyb20gJy4vU3RlcE5vZGVSZWNvcmQnO1xuaW1wb3J0IERlcGVuZGVuY3lRdWV1ZSBmcm9tICcuL0RlcGVuZGVuY3lRdWV1ZSc7XG5pbXBvcnQgeyBEZXBlbmRlbmN5LCBTdGVwTm9kZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IGlzSW5jbHVkZWRJbkRlcGVuZGVuY3lBcnJheSBmcm9tICcuL2lzSW5jbHVkZWRJbkRlcGVuZGVuY3lBcnJheSc7XG5cbmludGVyZmFjZSBSZXNvbHZlQWxsRGVwZW5kZW5jeUFyZ3Mge1xuICBkZXBlbmRlbmN5Q2hlY2tzOiBEZXBlbmRlbmN5Q2hlY2tzU3RhdGU7XG4gIGludmVydERlcGVuZGVuY3lDaGVja3M/OiBJbnZlcnREZXBlbmRlbmN5Q2hlY2tzU3RhdGU7XG59XG5cbmNvbnN0IGluaXRpYXRlSW52ZXJ0RGVwZW5kZW5jeSA9ICh7XG4gIGludmVydERlcGVuZGVuY3lDaGVja3MsXG4gIHN0ZXBJZCxcbiAgdHlwZSxcbn06IHtcbiAgaW52ZXJ0RGVwZW5kZW5jeUNoZWNrczogSW52ZXJ0RGVwZW5kZW5jeUNoZWNrc1N0YXRlO1xuICBzdGVwSWQ6IHN0cmluZztcbiAgdHlwZTogc3RyaW5nO1xufSkgPT4ge1xuICBpZiAoIWludmVydERlcGVuZGVuY3lDaGVja3NbdHlwZV0pIHtcbiAgICBpbnZlcnREZXBlbmRlbmN5Q2hlY2tzW3R5cGVdID0ge307XG4gIH1cbiAgaWYgKCFpbnZlcnREZXBlbmRlbmN5Q2hlY2tzW3R5cGVdW3N0ZXBJZF0pIHtcbiAgICBpbnZlcnREZXBlbmRlbmN5Q2hlY2tzW3R5cGVdW3N0ZXBJZF0gPSB7IGRlcGVuZGVuY3lDaGVja0xpc3Q6IFtdIH07XG4gIH1cbn07XG5cbmNvbnN0IGFkZE5vZGVUb1F1ZXVlRmFjdG9yeSA9IChxdWV1ZTogRGVwZW5kZW5jeVF1ZXVlKSA9PiAoXG4gIG5vZGU6IERlcGVuZGVuY3lcbikgPT4ge1xuICAvLyBjb25zdHJ1Y3QgbmV4dE5vZGVcbiAgY29uc3QgbmV4dE5vZGUgPSB7XG4gICAgc2NyaXB0VHlwZTogbm9kZS50eXBlLFxuICAgIHN0ZXBJZDogbm9kZS5zdGVwSWQsXG4gIH07XG5cbiAgaWYgKHF1ZXVlLmluY2x1ZGVzKG5leHROb2RlKSkge1xuICAgIC8vIGlmIG5leHROb2RlIGlzIG1ldCBpbiB0aGUgcXVldWUgYmVmb3JlLFxuICAgIC8vIGl0IG1lYW5zIHRoZXJlJ3MgY2lyY3VsYXIgZGVwZW5kZW5jeVxuICAgIHRocm93IG5ldyBFcnJvcignY2lyY3VsYXIgZGVwZW5kZW5jeSBkZXRlY3RlZCcpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5leHROb2RlIGlzIHNhZmUgdG8gYWRkIHRvIHF1ZXVlXG4gICAgcXVldWUucHVzaChuZXh0Tm9kZSk7XG4gIH1cbn07XG5cbmNvbnN0IGluc2VydE5vZGVJbnRvSW52ZXJ0RGVwZW5kZW5jeUNoZWNrcyA9ICh7XG4gIG5vZGUsXG4gIGN1cnJlbnROb2RlLFxuICBpbnZlcnREZXBlbmRlbmN5Q2hlY2tzLFxufToge1xuICBub2RlOiBEZXBlbmRlbmN5O1xuICBjdXJyZW50Tm9kZTogU3RlcE5vZGU7XG4gIGludmVydERlcGVuZGVuY3lDaGVja3M6IEludmVydERlcGVuZGVuY3lDaGVja3NTdGF0ZTtcbn0pID0+IHtcbiAgLy8gY29uc3RydWN0IGludmVydCBkZXBlbmRlbmN5IG5vZGVcbiAgY29uc3QgaW52ZXJ0RGVwZW5kZW5jeTogRGVwZW5kZW5jeSA9IHtcbiAgICBzdGVwSWQ6IGN1cnJlbnROb2RlLnN0ZXBJZCxcbiAgICB0eXBlOiBjdXJyZW50Tm9kZS5zY3JpcHRUeXBlLFxuICAgIGNob2ljZTogbm9kZS5jaG9pY2UsXG4gIH07XG4gIC8vIGluaXRpYXRlIHN0YXRlIGZvciB0aGUgbm9kZSBpZiBub3QgaW5pdGlhdGVkXG4gIGluaXRpYXRlSW52ZXJ0RGVwZW5kZW5jeSh7IGludmVydERlcGVuZGVuY3lDaGVja3MsIC4uLm5vZGUgfSk7XG4gIGlmIChjdXJyZW50Tm9kZS5zY3JpcHRUeXBlID09PSAnZGVsZXRlJyAmJiBjdXJyZW50Tm9kZS5zdGVwSWQgPT09ICdCJykge1xuICAgIGNvbnNvbGUubG9nKCdoZWxsbycpO1xuICB9XG5cbiAgLy8gaW5zZXJ0IHRoZSBpbnZlcnQgZGVwZW5kZW5jeSBub2RlIG9ubHkgaWYgbm90IGV4aXN0ZWRcbiAgLy8gaW4gdGhlIG5vZGUncyBpbnZlcnQgZGVwZW5kZW5jeSBjaGVjayBsaXN0XG4gIGNvbnN0IGludmVydERlcGVuZGVuY3lDaGVja0xpc3QgPVxuICAgIGludmVydERlcGVuZGVuY3lDaGVja3Nbbm9kZS50eXBlXVtub2RlLnN0ZXBJZF0uZGVwZW5kZW5jeUNoZWNrTGlzdDtcbiAgaWYgKFxuICAgICFpc0luY2x1ZGVkSW5EZXBlbmRlbmN5QXJyYXkoe1xuICAgICAgZGVwZW5kZW5jeTogaW52ZXJ0RGVwZW5kZW5jeSxcbiAgICAgIGFycmF5OiBpbnZlcnREZXBlbmRlbmN5Q2hlY2tMaXN0LFxuICAgIH0pXG4gICkge1xuICAgIGludmVydERlcGVuZGVuY3lDaGVja0xpc3QucHVzaChpbnZlcnREZXBlbmRlbmN5KTtcbiAgfVxufTtcblxuY29uc3QgaW5zZXJ0Tm9kZUludG9EZXBlbmRlbmN5Q2hlY2tMaXN0RmFjdG9yeSA9ICh7XG4gIGluZGV4LFxuICBkZXBlbmRlbmN5Q2hlY2tMaXN0LFxuICBjdXJyZW50Tm9kZSxcbiAgaW52ZXJ0RGVwZW5kZW5jeUNoZWNrcyxcbn06IHtcbiAgaW5kZXg6IG51bWJlcjtcbiAgZGVwZW5kZW5jeUNoZWNrTGlzdDogRGVwZW5kZW5jeVtdO1xuICBjdXJyZW50Tm9kZTogU3RlcE5vZGU7XG4gIGludmVydERlcGVuZGVuY3lDaGVja3M6IEludmVydERlcGVuZGVuY3lDaGVja3NTdGF0ZTtcbn0pID0+IChub2RlOiBEZXBlbmRlbmN5KSA9PiB7XG4gIC8vIGluc2VydCBkZXBlbmRlbmN5IG5vZGUgb25seSBpZiBub3QgZXhpc3RlZFxuICBpZiAoXG4gICAgIWlzSW5jbHVkZWRJbkRlcGVuZGVuY3lBcnJheSh7XG4gICAgICBkZXBlbmRlbmN5OiBub2RlLFxuICAgICAgYXJyYXk6IGRlcGVuZGVuY3lDaGVja0xpc3QsXG4gICAgfSlcbiAgKSB7XG4gICAgZGVwZW5kZW5jeUNoZWNrTGlzdC5zcGxpY2UoaW5kZXgsIDAsIG5vZGUpO1xuICB9XG4gIGluc2VydE5vZGVJbnRvSW52ZXJ0RGVwZW5kZW5jeUNoZWNrcyh7XG4gICAgbm9kZSxcbiAgICBjdXJyZW50Tm9kZSxcbiAgICBpbnZlcnREZXBlbmRlbmN5Q2hlY2tzLFxuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCByZXNvbHZlQWxsRGVwZW5kZW5jeSA9ICh7XG4gIGRlcGVuZGVuY3lDaGVja3MsXG4gIGludmVydERlcGVuZGVuY3lDaGVja3MgPSB7fSxcbn06IFJlc29sdmVBbGxEZXBlbmRlbmN5QXJncykgPT5cbiAgcHJvZHVjZSh7IGRlcGVuZGVuY3lDaGVja3MsIGludmVydERlcGVuZGVuY3lDaGVja3MgfSwgKGRyYWZ0KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgZGVwZW5kZW5jeUNoZWNrczogZHJhZnREZXBlbmRlbmN5Q2hlY2tzLFxuICAgICAgaW52ZXJ0RGVwZW5kZW5jeUNoZWNrczogZHJhZnRJbnZlcnREZXBlbmRlbmN5Q2hlY2tzLFxuICAgIH0gPSBkcmFmdDtcblxuICAgIGNvbnN0IHJlc29sdmVkID0gbmV3IFN0ZXBOb2RlUmVjb3JkKCk7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTdGVwTm9kZVJlY29yZCgpO1xuXG4gICAgT2JqZWN0LmtleXMoZHJhZnREZXBlbmRlbmN5Q2hlY2tzKS5mb3JFYWNoKChzY3JpcHRUeXBlKSA9PiB7XG4gICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBzY3JpcHRUeXBlXG4gICAgICBkcmFmdERlcGVuZGVuY3lDaGVja3Nbc2NyaXB0VHlwZV0uaWRzLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGRlcGVuZGVuY3kgZWxlbWVudCBpbiBlYWNoIHNjcmlwdFR5cGVcbiAgICAgICAgY29uc3Qgc3RlcElkID0gaWQudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gaW5pdGlhdGUgcXVldWVcbiAgICAgICAgY29uc3QgcXVldWUgPSBuZXcgRGVwZW5kZW5jeVF1ZXVlKHsgc2NyaXB0VHlwZSwgc3RlcElkIH0pO1xuXG4gICAgICAgIC8vIGRlY2xhcmUgZnVuY3Rpb24gdG8gYWRkIGEgbm9kZSB0byBxdWV1ZVxuICAgICAgICAvLyB1c2UgZmlyc3Qgc2NyaXB0VHlwZSBhcyBkZWZhdWx0IHR5cGVcbiAgICAgICAgY29uc3QgYWRkTm9kZVRvUXVldWUgPSBhZGROb2RlVG9RdWV1ZUZhY3RvcnkocXVldWUpO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgcHJvY2Vzc2luZyBldmVyeSBub2RlIGluIHF1ZXVlXG5cbiAgICAgICAgICAvLyBjdXJyZW50IHBvaW50ZXIgbm9kZVxuICAgICAgICAgIGNvbnN0IG5vZGVUb0NoZWNrID0gcXVldWVbcXVldWUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBub2RlIGluIHRoZSBzdGF0ZVxuICAgICAgICAgIGNvbnN0IHN0ZXBUb1VwZGF0ZSA9XG4gICAgICAgICAgICBkcmFmdERlcGVuZGVuY3lDaGVja3Nbbm9kZVRvQ2hlY2suc2NyaXB0VHlwZV0uZW50aXRpZXNbXG4gICAgICAgICAgICAgIG5vZGVUb0NoZWNrLnN0ZXBJZFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWQuaW5jbHVkZXMobm9kZVRvQ2hlY2spKSB7XG4gICAgICAgICAgICAvLyBpZiBjdXJyZW50IG5vZGUgaXMgcmVzb2x2ZWRcblxuICAgICAgICAgICAgcXVldWUucG9wKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGVwVG9VcGRhdGUpIHtcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgbm9kZSBzdGlsbCBoYXZlIGRlcGVuZGVuY3kgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgaWYgKCFzZWVuLmluY2x1ZGVzKG5vZGVUb0NoZWNrKSkge1xuICAgICAgICAgICAgICAvLyBpZiBjdXJyZW50IG5vZGUgbm90IHNlZW4gYmVmb3JlXG4gICAgICAgICAgICAgIC8vIGluaXRpYXRlIGN1cnJlbnQgbm9kZSdzIGRlcGVuZGVuY3kgYXJyYXlcbiAgICAgICAgICAgICAgc3RlcFRvVXBkYXRlLmRlcGVuZGVuY3lDaGVja0xpc3QgPSBbLi4uc3RlcFRvVXBkYXRlLmRlcGVuZGVuY3ldO1xuICAgICAgICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHNlZW5cbiAgICAgICAgICAgICAgc2Vlbi5hZGQobm9kZVRvQ2hlY2spO1xuXG4gICAgICAgICAgICAgIC8vIGFkZCBhbGwgZGVwZW5kZW50IG5vZGUgdG8gcXVldWVcbiAgICAgICAgICAgICAgc3RlcFRvVXBkYXRlLmRlcGVuZGVuY3kuZm9yRWFjaChhZGROb2RlVG9RdWV1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjdXJyZW50IG5vZGUgaGFzIGJlZW4gc2VlbiBiZWZvcmVcbiAgICAgICAgICAgICAgLy8gaXQgaW1wbGllcyB0aGF0IGN1cnJlbnQgbm9kZSBoYXZlIGFsbCBub2RlcyBpbiBkZXBlbmRlbmN5IHJlc29sdmVkXG4gICAgICAgICAgICAgIGNvbnN0IHsgZGVwZW5kZW5jeUNoZWNrTGlzdCA9IFtdIH0gPSBzdGVwVG9VcGRhdGU7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSBkZXBlbmRlbmN5Q2hlY2tMaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGV2ZXJ5IG5vZGUgaW4gY3VycmVudCBkZXBlbmRlbmN5IGNoZWNrIGxpc3QgZnJvbSB0aGUgZW5kXG5cbiAgICAgICAgICAgICAgICAvLyBzdGVwIHRoYXQgY29ycmVzcG9uZHMgdG8gY3VycmVudCBub2RlIHRvIHJlcGxhY2VcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwVG9SZXBsYWNlID1cbiAgICAgICAgICAgICAgICAgIGRyYWZ0RGVwZW5kZW5jeUNoZWNrc1tkZXBlbmRlbmN5Q2hlY2tMaXN0W2ldLnR5cGUgfHwgJyddXG4gICAgICAgICAgICAgICAgICAgID8uZW50aXRpZXNbZGVwZW5kZW5jeUNoZWNrTGlzdFtpXS5zdGVwSWRdO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwVG9SZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiBzdGVwVG9SZXBsYWNlIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgLy8gaXQgbWVhbnMgdGhlIHN0ZXBUb1JlcGxhY2UgaGFzIGRlcGVuZGVuY3lDaGVja0xpc3QgdG8gcmVwbGFjZVxuXG4gICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdGhlIGN1cnJlbnQgbm9kZVRvUmVwbGFjZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVRvUmVwbGFjZSA9IGRlcGVuZGVuY3lDaGVja0xpc3Quc3BsaWNlKGksIDEpWzBdO1xuXG4gICAgICAgICAgICAgICAgICAvLyBjb3B5IHN0ZXBUb1JlcGxhY2UncyBkZXBlbmRlbmN5Q2hlY2tMaXN0IHRvIHN0ZXBUb1VwZGF0ZSdzIGRlcGVuZGVuY3lDaGVja0xpc3RcbiAgICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgZHVwbGljYXRlZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgICAgICAgICAgICAgc3RlcFRvUmVwbGFjZS5kZXBlbmRlbmN5Q2hlY2tMaXN0Py5mb3JFYWNoKFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnROb2RlSW50b0RlcGVuZGVuY3lDaGVja0xpc3RGYWN0b3J5KHtcbiAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmN5Q2hlY2tMaXN0LFxuICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlOiBub2RlVG9DaGVjayxcbiAgICAgICAgICAgICAgICAgICAgICBpbnZlcnREZXBlbmRlbmN5Q2hlY2tzOiBkcmFmdEludmVydERlcGVuZGVuY3lDaGVja3MsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAvLyBpbnNlcnQgdGhlIGN1cnJlbnQgbm9kZVRvUmVwbGFjZSBhZ2FpbiBpZiBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgICBpbnNlcnROb2RlSW50b0RlcGVuZGVuY3lDaGVja0xpc3RGYWN0b3J5KHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lDaGVja0xpc3QsXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlOiBub2RlVG9DaGVjayxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0RGVwZW5kZW5jeUNoZWNrczogZHJhZnRJbnZlcnREZXBlbmRlbmN5Q2hlY2tzLFxuICAgICAgICAgICAgICAgICAgfSkobm9kZVRvUmVwbGFjZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydE5vZGVJbnRvSW52ZXJ0RGVwZW5kZW5jeUNoZWNrcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGRlcGVuZGVuY3lDaGVja0xpc3RbaV0sXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlOiBub2RlVG9DaGVjayxcbiAgICAgICAgICAgICAgICAgICAgaW52ZXJ0RGVwZW5kZW5jeUNoZWNrcyxcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJlc29sdmVkLmFkZChub2RlVG9DaGVjayk7XG4gICAgICAgICAgICAgIHF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjdXJyZW50IG5vZGUgZG9lcyBub3QgaGF2ZSBhbnkgZGVwZW5kZW5jeVxuICAgICAgICAgICAgcmVzb2x2ZWQuYWRkKG5vZGVUb0NoZWNrKTtcbiAgICAgICAgICAgIHF1ZXVlLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZHJhZnQ7XG4gIH0pO1xuXG5leHBvcnQgY29uc3QgcmVzb2x2ZURlcGVuZGVuY3kgPSAoKSA9PiB7fTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/features/dependency/resolveDependency.ts\n");

/***/ })

})